//
// File: SimulateNarxNetwork.cpp
//
// MATLAB Coder version            : 3.4
// C/C++ source code generated on  : 20-Mar-2018 12:35:48
//

// Include Files
#include "rt_nonfinite.h"
#include "CalcShewhart.h"
#include "EppsPallyCriterion.h"
#include "GetSample.h"
#include "GiriCriterion.h"
#include "HegazyGreenCriterion.h"
#include "MakeMultipleNNPredicions.h"
#include "ShapiroWeakCriterion.h"
#include "SimulateNarxNetwork.h"
#include "CalcShewhart_data.h"

// Function Definitions

//
// MYNEURALNETWORKFUNCTION neural network simulation function.
//
//  Generated by Neural Network Toolbox function genFunction, 18-Mar-2018 23:34:59.
//
//  [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments:
//    x1 = 1xTS matrix, input #1
//    x2 = 1xTS matrix, input #2
//    xi1 = 1x5 matrix, initial 5 delay states for input #1.
//    xi2 = 1x5 matrix, initial 5 delay states for input #2.
//  and returns:
//    y1 = 1xTS matrix, output #1
//    xf1 = 1x5 matrix, final 5 delay states for input #1.
//    xf2 = 1x5 matrix, final 5 delay states for input #2.
//  where TS is the number of timesteps.
// Arguments    : double x1
//                double x2
//                const double xi1[5]
//                const double xi2[5]
//                double *b_y1
//                double xf1[5]
//                double xf2[5]
// Return Type  : void
//
void SimulateNarxNetwork(double x1, double x2, const double xi1[5], const double
  xi2[5], double *b_y1, double xf1[5], double xf2[5])
{
  double dv8[5];
  int i7;
  double xd1[6];
  double xd2[6];
  double d2;
  int k;
  double d3;
  double a[10];

  //  ===== NEURAL NETWORK CONSTANTS =====
  //  Input 1
  //  Input 2
  //  Layer 1
  //  Layer 2
  //  Output 1
  //  ===== SIMULATION ========
  //  Dimensions
  //  timesteps
  //  Input 1 Delay States
  mapminmax_apply(xi1, dv8);
  for (i7 = 0; i7 < 5; i7++) {
    xd1[i7] = dv8[i7];
  }

  //  Input 2 Delay States
  mapminmax_apply(xi2, dv8);
  for (i7 = 0; i7 < 5; i7++) {
    xd2[i7] = dv8[i7];
  }

  //  Allocate Outputs
  //  Time loop
  //  Rotating delay state position
  //  Input 1
  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  xd1[5] = (x1 - -0.999999682931835) * 1.00000031706827 + -1.0;

  //  Input 2
  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  xd2[5] = (x2 - -0.999999682931835) * 1.00000031706827 + -1.0;

  //  Layer 1
  //  Sigmoid Symmetric Transfer Function
  //  Layer 2
  //  Output 1
  //  Map Minimum and Maximum Output Reverse-Processing Function
  d2 = 0.0;
  for (k = 0; k < 10; k++) {
    d3 = 0.0;
    for (i7 = 0; i7 < 5; i7++) {
      d3 += dv0[k + 10 * i7] * xd1[4 - i7];
    }

    a[k] = 0.0;
    for (i7 = 0; i7 < 5; i7++) {
      a[k] += dv3[k + 10 * i7] * xd2[4 - i7];
    }

    d2 += dv1[k] * (2.0 / (1.0 + std::exp(-2.0 * ((dv2[k] + d3) + a[k]))) - 1.0);
  }

  *b_y1 = ((-0.51213534382060155 + d2) - -1.0) / 1.00000031706827 +
    -0.999999682931835;

  //  Final delay states
  xf1[4] = x1;
  for (i7 = 0; i7 < 4; i7++) {
    xf1[i7] = xi1[1 + i7];
    xf2[i7] = xi2[1 + i7];
  }

  xf2[4] = x2;
}

//
// Arguments    : const double x[5]
//                double y[5]
// Return Type  : void
//
void mapminmax_apply(const double x[5], double y[5])
{
  int k;
  double a[5];

  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  for (k = 0; k < 5; k++) {
    a[k] = x[k] - -0.999999682931835;
  }

  for (k = 0; k < 5; k++) {
    a[k] *= 1.00000031706827;
  }

  for (k = 0; k < 5; k++) {
    y[k] = a[k] + -1.0;
  }
}

//
// File trailer for SimulateNarxNetwork.cpp
//
// [EOF]
//
