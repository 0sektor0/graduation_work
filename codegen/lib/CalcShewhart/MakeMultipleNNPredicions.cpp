//
// File: MakeMultipleNNPredicions.cpp
//
// MATLAB Coder version            : 3.4
// C/C++ source code generated on  : 20-Mar-2018 12:35:48
//

// Include Files
#include "rt_nonfinite.h"
#include "CalcShewhart.h"
#include "EppsPallyCriterion.h"
#include "GetSample.h"
#include "GiriCriterion.h"
#include "HegazyGreenCriterion.h"
#include "MakeMultipleNNPredicions.h"
#include "ShapiroWeakCriterion.h"
#include "SimulateNarxNetwork.h"
#include "CalcShewhart_emxutil.h"
#include "CalcShewhart_data.h"

// Function Definitions

//
// Arguments    : const emxArray_real_T *input
//                double predictions_count
//                emxArray_real_T *prediction
// Return Type  : void
//
void MakeMultipleNNPredicions(const emxArray_real_T *input, double
  predictions_count, emxArray_real_T *prediction)
{
  int i6;
  int acoef;
  int i;
  emxArray_real_T *xd1;
  emxArray_real_T *a;
  int k;
  double out_delay[5];
  int szc;
  double x[5];
  double xd2[6];
  double d0;
  double d1;
  double b_a[10];
  predictions_count = (predictions_count + 5.0) + 1.0;
  i6 = prediction->size[0] * prediction->size[1];
  prediction->size[0] = 1;
  prediction->size[1] = (int)predictions_count;
  emxEnsureCapacity_real_T(prediction, i6);
  acoef = (int)predictions_count;
  for (i6 = 0; i6 < acoef; i6++) {
    prediction->data[i6] = 0.0;
  }

  for (i6 = 0; i6 < 6; i6++) {
    prediction->data[i6] = input->data[i6];
  }

  i = 0;
  emxInit_real_T(&xd1, 2);
  emxInit_real_T(&a, 2);
  while (i <= (int)((predictions_count - 5.0) + 1.0) - 1) {
    if (1.0 + (double)i > ((1.0 + (double)i) + 5.0) - 1.0) {
      i6 = 1;
      k = 1;
    } else {
      i6 = i + 1;
      k = (int)(((1.0 + (double)i) + 5.0) - 1.0) + 1;
    }

    for (acoef = 0; acoef < 5; acoef++) {
      out_delay[acoef] = prediction->data[(int)((1.0 + (double)i) + (1.0 +
        (double)acoef)) - 1];
    }

    // MYNEURALNETWORKFUNCTION neural network simulation function.
    //
    //  Generated by Neural Network Toolbox function genFunction, 18-Mar-2018 23:34:59. 
    //
    //  [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments: 
    //    x1 = 1xTS matrix, input #1
    //    x2 = 1xTS matrix, input #2
    //    xi1 = 1x5 matrix, initial 5 delay states for input #1.
    //    xi2 = 1x5 matrix, initial 5 delay states for input #2.
    //  and returns:
    //    y1 = 1xTS matrix, output #1
    //    xf1 = 1x5 matrix, final 5 delay states for input #1.
    //    xf2 = 1x5 matrix, final 5 delay states for input #2.
    //  where TS is the number of timesteps.
    //  ===== NEURAL NETWORK CONSTANTS =====
    //  Input 1
    //  Input 2
    //  Layer 1
    //  Layer 2
    //  Output 1
    //  ===== SIMULATION ========
    //  Dimensions
    //  timesteps
    //  Input 1 Delay States
    //  ===== MODULE FUNCTIONS ========
    //  Map Minimum and Maximum Input Processing Function
    acoef = xd1->size[0] * xd1->size[1];
    xd1->size[0] = 1;
    xd1->size[1] = k - i6;
    emxEnsureCapacity_real_T(xd1, acoef);
    if (xd1->size[1] != 0) {
      szc = xd1->size[1];
      acoef = (k - i6 != 1);
      for (k = 0; k < szc; k++) {
        xd1->data[xd1->size[0] * k] = prediction->data[(i6 + acoef * k) - 1] -
          -0.999999682931835;
      }
    }

    i6 = a->size[0] * a->size[1];
    a->size[0] = 1;
    a->size[1] = xd1->size[1];
    emxEnsureCapacity_real_T(a, i6);
    acoef = xd1->size[0] * xd1->size[1];
    for (i6 = 0; i6 < acoef; i6++) {
      a->data[i6] = xd1->data[i6];
    }

    acoef = xd1->size[1];
    i6 = xd1->size[0] * xd1->size[1];
    xd1->size[0] = 1;
    xd1->size[1] = acoef;
    emxEnsureCapacity_real_T(xd1, i6);
    if (xd1->size[1] != 0) {
      szc = xd1->size[1];
      acoef = (a->size[1] != 1);
      for (k = 0; k < szc; k++) {
        xd1->data[xd1->size[0] * k] = a->data[a->size[0] * (acoef * k)] *
          1.00000031706827;
      }
    }

    i6 = a->size[0] * a->size[1];
    a->size[0] = 1;
    a->size[1] = xd1->size[1];
    emxEnsureCapacity_real_T(a, i6);
    acoef = xd1->size[0] * xd1->size[1];
    for (i6 = 0; i6 < acoef; i6++) {
      a->data[i6] = xd1->data[i6];
    }

    acoef = xd1->size[1];
    i6 = xd1->size[0] * xd1->size[1];
    xd1->size[0] = 1;
    xd1->size[1] = acoef;
    emxEnsureCapacity_real_T(xd1, i6);
    if (xd1->size[1] != 0) {
      szc = xd1->size[1];
      acoef = (a->size[1] != 1);
      for (k = 0; k < szc; k++) {
        xd1->data[xd1->size[0] * k] = a->data[a->size[0] * (acoef * k)] + -1.0;
      }
    }

    acoef = xd1->size[1];
    i6 = xd1->size[0] * xd1->size[1];
    xd1->size[1] = acoef + 1;
    emxEnsureCapacity_real_T(xd1, i6);
    xd1->data[acoef] = 0.0;

    //  Input 2 Delay States
    mapminmax_apply(out_delay, x);
    for (i6 = 0; i6 < 5; i6++) {
      xd2[i6] = x[i6];
    }

    //  Allocate Outputs
    //  Time loop
    //  Rotating delay state position
    //  Input 1
    xd1->data[xd1->size[0] * 5] = 4.6629367034256575E-15;

    //  Input 2
    xd2[5] = 4.6629367034256575E-15;

    //  Layer 1
    for (k = 0; k < 5; k++) {
      if (4 - k == 0) {
        out_delay[k] = 0.0;
      } else {
        out_delay[k] = (int)std::fmod(4.0 + -(((double)k + 1.0) - 1.0), 6.0);
      }
    }

    for (i6 = 0; i6 < 5; i6++) {
      x[i6] = xd1->data[xd1->size[0] * (int)out_delay[i6]];
    }

    //  Sigmoid Symmetric Transfer Function
    //  Layer 2
    //  Output 1
    //  Map Minimum and Maximum Output Reverse-Processing Function
    //  Final delay states
    d0 = 0.0;
    for (k = 0; k < 10; k++) {
      d1 = 0.0;
      for (i6 = 0; i6 < 5; i6++) {
        d1 += dv0[k + 10 * i6] * x[i6];
      }

      b_a[k] = 0.0;
      for (i6 = 0; i6 < 5; i6++) {
        b_a[k] += dv3[k + 10 * i6] * xd2[4 - i6];
      }

      d0 += dv1[k] * (2.0 / (1.0 + std::exp(-2.0 * ((dv2[k] + d1) + b_a[k]))) -
                      1.0);
    }

    prediction->data[prediction->size[0] * ((int)(((1.0 + (double)i) + 5.0) +
      1.0) - 1)] = ((-0.51213534382060155 + d0) - -1.0) / 1.00000031706827 +
      -0.999999682931835;
    i++;
  }

  emxFree_real_T(&a);
  emxFree_real_T(&xd1);
}

//
// File trailer for MakeMultipleNNPredicions.cpp
//
// [EOF]
//
