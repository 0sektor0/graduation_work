//
// File: SimulateNarx.cpp
//
// MATLAB Coder version            : 3.4
// C/C++ source code generated on  : 05-Mar-2018 18:06:23
//

// Include Files
#include "rt_nonfinite.h"
#include "EppsPallyCriterion.h"
#include "GetSample.h"
#include "GiriCriterion.h"
#include "HegazyGreenCriterion.h"
#include "ShapiroWeakCriterion.h"
#include "ShowPlot.h"
#include "SimulateNarx.h"
#include "mod.h"
#include "libNarxStatSys_emxutil.h"
#include "bsxfun.h"

// Function Definitions

//
// MYNEURALNETWORKFUNCTION neural network simulation function.
//
//  Generated by Neural Network Toolbox function genFunction, 05-Mar-2018 02:03:52.
//
//  [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments:
//    x1 = 1xTS matrix, input #1
//    x2 = 1xTS matrix, input #2
//    xi1 = 1x5 matrix, initial 5 delay states for input #1.
//    xi2 = 1x5 matrix, initial 5 delay states for input #2.
//  and returns:
//    y1 = 1xTS matrix, output #1
//    xf1 = 1x5 matrix, final 5 delay states for input #1.
//    xf2 = 1x5 matrix, final 5 delay states for input #2.
//  where TS is the number of timesteps.
// Arguments    : const emxArray_real_T *x1
//                const emxArray_real_T *x2
//                const emxArray_real_T *xi1
//                const emxArray_real_T *xi2
//                emxArray_real_T *b_y1
//                double xf1_data[]
//                int xf1_size[2]
//                double xf2_data[]
//                int xf2_size[2]
// Return Type  : void
//
void SimulateNarx(const emxArray_real_T *x1, const emxArray_real_T *x2, const
                  emxArray_real_T *xi1, const emxArray_real_T *xi2,
                  emxArray_real_T *b_y1, double xf1_data[], int xf1_size[2],
                  double xf2_data[], int xf2_size[2])
{
  emxArray_real_T *xd1;
  int TS;
  int csz_idx_1;
  int i5;
  emxArray_real_T *b_xd1;
  int acoef;
  int k;
  emxArray_real_T *xd2;
  int trueCount;
  int tmp_data[5];
  unsigned int b_x1;
  double r[5];
  double dv4[5];
  int b_tmp_data[5];
  unsigned int uv1[5];
  double x[5];
  unsigned int uv2[5];
  double d0;
  double d1;
  double a[10];
  static const double b_a[50] = { 0.15953178999074935, 1.0665109884445469,
    0.48709849061539817, -0.46488478584157095, -0.2652232776466299,
    0.40742763723298836, -0.64433502300773415, -0.29627153905886039,
    -0.51631884461305388, -0.67110069290497232, -0.622264525073996,
    -0.081450026684921489, 0.27820680189382913, 0.089763777097414815,
    -0.68559072010026434, 0.47630439354499166, -0.90520490178999269,
    -0.74263365445905272, 0.76940051705387169, 0.46318581921767771,
    0.060830731347264418, 0.27459298178719604, 0.58772234409607582,
    -0.57635317225519378, -0.022421095150856205, -0.36293988057352966,
    -0.94167174055582059, 0.405148694614485, 0.58626058298144779,
    0.51528679674074518, -0.77558313935781709, -0.3522242378409875,
    0.65687008264506652, 0.39344424906312009, -0.497609549134195,
    -1.0732853474200998, -0.508450894414514, 0.47174511736310143,
    -0.097486366025991755, 0.90375770290899815, -0.85113105288273216,
    -1.0097215316539379, 0.14048086017385972, -0.27872934599624055,
    0.3687419299587596, 0.2945468590919807, -0.20712011737187977,
    -0.50966222731695621, 0.096143620520296763, 0.64160533728983637 };

  int c_tmp_data[5];
  static const double c_a[10] = { -0.0011230187451937237, -0.94577252909427667,
    -0.00050514245379962, -0.4778234232333447, -0.81217673682454894,
    -0.090880500192812769, 3.9656810838924306E-6, 1.864497057776055E-5,
    0.946606537725403, 0.79011075296776689 };

  static const double b1[10] = { -1.7090172203160829, -1.4346618247354768,
    -1.0248798375554911, 0.15187863316150466, -0.11704147597611042,
    -0.058363867728379856, -0.54156627864489515, -1.0316357902912727,
    -1.261703260857886, -1.8689621535231205 };

  static const double d_a[50] = { 0.61487828302025849, -0.24702381325767933,
    -0.2265681474568062, 0.844988687525079, 0.60613872531399249,
    0.33934073764760886, -0.59932709214792923, -0.847449398541364,
    -0.77038388509369848, -0.24029552282126776, -0.70794674024522541,
    -0.2657612487007126, 0.27659540722185044, -0.44373905595454421,
    0.59142650823268106, -0.19666201233376646, 0.064315096078469677,
    -0.82408525969485147, -0.67226618897118662, -0.62304276505939882,
    -0.44789323152365934, 0.58310493885226289, 0.80571687939104064,
    -0.56943084565509938, -0.79282392827066772, 0.20399427948173929,
    0.12319735013463742, -0.522327186535723, 0.81173112134442449,
    0.091271865071466313, 0.25969355851680626, -0.37176500274580615,
    -0.84451376141083323, 0.76222722429431777, 0.71190089804275325,
    0.84854120256203158, -0.59545680144108992, -0.26706284679096115,
    0.45821689805859794, -0.62730015198289846, 0.24085764928703574,
    -0.30066683680964496, -0.20773793129614079, -0.37701152227248752,
    -0.60236911339393817, 0.036192038533045714, -0.1805366773557566,
    -0.3938055391763764, -0.050168609551875638, -0.0042620415811663436 };

  int d_tmp_data[5];
  emxInit_real_T(&xd1, 2);

  //  ===== NEURAL NETWORK CONSTANTS =====
  //  Input 1
  //  Input 2
  //  Layer 1
  //  Layer 2
  //  Output 1
  //  ===== SIMULATION ========
  //  Dimensions
  TS = x1->size[1];

  //  timesteps
  //  Input 1 Delay States
  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  csz_idx_1 = xi1->size[1];
  i5 = xd1->size[0] * xd1->size[1];
  xd1->size[0] = 1;
  xd1->size[1] = csz_idx_1;
  emxEnsureCapacity_real_T(xd1, i5);
  if (xd1->size[1] != 0) {
    csz_idx_1 = xd1->size[1];
    acoef = (xi1->size[1] != 1);
    for (k = 0; k < csz_idx_1; k++) {
      xd1->data[xd1->size[0] * k] = xi1->data[xi1->size[0] * (acoef * k)] - 1.0;
    }
  }

  emxInit_real_T(&b_xd1, 2);
  i5 = b_xd1->size[0] * b_xd1->size[1];
  b_xd1->size[0] = 1;
  b_xd1->size[1] = xd1->size[1];
  emxEnsureCapacity_real_T(b_xd1, i5);
  csz_idx_1 = xd1->size[0] * xd1->size[1];
  for (i5 = 0; i5 < csz_idx_1; i5++) {
    b_xd1->data[i5] = xd1->data[i5];
  }

  bsxfun(b_xd1, xd1);
  i5 = b_xd1->size[0] * b_xd1->size[1];
  b_xd1->size[0] = 1;
  b_xd1->size[1] = xd1->size[1];
  emxEnsureCapacity_real_T(b_xd1, i5);
  csz_idx_1 = xd1->size[0] * xd1->size[1];
  for (i5 = 0; i5 < csz_idx_1; i5++) {
    b_xd1->data[i5] = xd1->data[i5];
  }

  emxInit_real_T(&xd2, 2);
  b_bsxfun(b_xd1, xd1);
  csz_idx_1 = xd1->size[1];
  i5 = xd1->size[0] * xd1->size[1];
  xd1->size[1] = csz_idx_1 + 1;
  emxEnsureCapacity_real_T(xd1, i5);
  xd1->data[csz_idx_1] = 0.0;

  //  Input 2 Delay States
  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  csz_idx_1 = xi2->size[1];
  i5 = xd2->size[0] * xd2->size[1];
  xd2->size[0] = 1;
  xd2->size[1] = csz_idx_1;
  emxEnsureCapacity_real_T(xd2, i5);
  if (xd2->size[1] != 0) {
    csz_idx_1 = xd2->size[1];
    acoef = (xi2->size[1] != 1);
    for (k = 0; k < csz_idx_1; k++) {
      xd2->data[xd2->size[0] * k] = xi2->data[xi2->size[0] * (acoef * k)] - 2.0;
    }
  }

  i5 = b_xd1->size[0] * b_xd1->size[1];
  b_xd1->size[0] = 1;
  b_xd1->size[1] = xd2->size[1];
  emxEnsureCapacity_real_T(b_xd1, i5);
  csz_idx_1 = xd2->size[0] * xd2->size[1];
  for (i5 = 0; i5 < csz_idx_1; i5++) {
    b_xd1->data[i5] = xd2->data[i5];
  }

  bsxfun(b_xd1, xd2);
  i5 = b_xd1->size[0] * b_xd1->size[1];
  b_xd1->size[0] = 1;
  b_xd1->size[1] = xd2->size[1];
  emxEnsureCapacity_real_T(b_xd1, i5);
  csz_idx_1 = xd2->size[0] * xd2->size[1];
  for (i5 = 0; i5 < csz_idx_1; i5++) {
    b_xd1->data[i5] = xd2->data[i5];
  }

  b_bsxfun(b_xd1, xd2);
  csz_idx_1 = xd2->size[1];
  i5 = xd2->size[0] * xd2->size[1];
  xd2->size[1] = csz_idx_1 + 1;
  emxEnsureCapacity_real_T(xd2, i5);
  xd2->data[csz_idx_1] = 0.0;

  //  Allocate Outputs
  //  Time loop
  i5 = b_y1->size[0] * b_y1->size[1];
  b_y1->size[0] = 1;
  b_y1->size[1] = x1->size[1];
  emxEnsureCapacity_real_T(b_y1, i5);
  acoef = 0;
  emxFree_real_T(&b_xd1);
  while (acoef <= TS - 1) {
    //  Rotating delay state position
    csz_idx_1 = (int)std::fmod((1.0 + (double)acoef) + 4.0, 6.0);

    //  Input 1
    //  ===== MODULE FUNCTIONS ========
    //  Map Minimum and Maximum Input Processing Function
    xd1->data[xd1->size[0] * csz_idx_1] = (x1->data[x1->size[0] * acoef] - 1.0) *
      0.002002002002002 + -1.0;

    //  Input 2
    //  ===== MODULE FUNCTIONS ========
    //  Map Minimum and Maximum Input Processing Function
    xd2->data[xd2->size[0] * csz_idx_1] = (x2->data[x2->size[0] * acoef] - 2.0) *
      0.002002002002002 + -1.0;

    //  Layer 1
    for (i5 = 0; i5 < 5; i5++) {
      r[i5] = (double)(csz_idx_1 - i5) - 1.0;
    }

    b_mod(r, dv4);
    for (i5 = 0; i5 < 5; i5++) {
      x[i5] = xd1->data[xd1->size[0] * ((int)(dv4[i5] + 1.0) - 1)];
    }

    for (i5 = 0; i5 < 5; i5++) {
      r[i5] = (double)(csz_idx_1 - i5) - 1.0;
    }

    b_mod(r, dv4);
    for (i5 = 0; i5 < 5; i5++) {
      r[i5] = xd2->data[xd2->size[0] * ((int)(dv4[i5] + 1.0) - 1)];
    }

    //  Sigmoid Symmetric Transfer Function
    //  Layer 2
    //  Output 1
    //  Map Minimum and Maximum Output Reverse-Processing Function
    d0 = 0.0;
    for (k = 0; k < 10; k++) {
      d1 = 0.0;
      for (i5 = 0; i5 < 5; i5++) {
        d1 += b_a[k + 10 * i5] * x[i5];
      }

      a[k] = 0.0;
      for (i5 = 0; i5 < 5; i5++) {
        a[k] += d_a[k + 10 * i5] * r[i5];
      }

      d0 += c_a[k] * (2.0 / (1.0 + std::exp(-2.0 * ((b1[k] + d1) + a[k]))) - 1.0);
    }

    b_y1->data[b_y1->size[0] * acoef] = ((0.69783699575542446 + d0) - -1.0) /
      0.002002002002002 + 2.0;
    acoef++;
  }

  emxFree_real_T(&xd2);
  emxFree_real_T(&xd1);

  //  Final delay states
  k = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U <= 5U) {
      k++;
    }
  }

  acoef = 0;
  trueCount = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U <= 5U) {
      tmp_data[acoef] = csz_idx_1 + 1;
      acoef++;
    }

    if (((unsigned int)TS + csz_idx_1) + 1U > 5U) {
      trueCount++;
    }
  }

  acoef = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U > 5U) {
      b_tmp_data[acoef] = csz_idx_1 + 1;
      acoef++;
    }
  }

  b_x1 = x1->size[1] + 1U;
  for (i5 = 0; i5 < 5; i5++) {
    uv1[i5] = i5 + b_x1;
  }

  b_x1 = x1->size[1] + 1U;
  for (i5 = 0; i5 < 5; i5++) {
    uv2[i5] = i5 + b_x1;
  }

  xf1_size[0] = 1;
  xf1_size[1] = k + trueCount;
  for (i5 = 0; i5 < k; i5++) {
    xf1_data[xf1_size[0] * i5] = xi1->data[xi1->size[0] * ((int)uv1[tmp_data[i5]
      - 1] - 1)];
  }

  for (i5 = 0; i5 < trueCount; i5++) {
    xf1_data[xf1_size[0] * (i5 + k)] = x1->data[x1->size[0] * ((int)((double)
      uv2[b_tmp_data[i5] - 1] - 5.0) - 1)];
  }

  k = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U <= 5U) {
      k++;
    }
  }

  acoef = 0;
  trueCount = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U <= 5U) {
      c_tmp_data[acoef] = csz_idx_1 + 1;
      acoef++;
    }

    if (((unsigned int)TS + csz_idx_1) + 1U > 5U) {
      trueCount++;
    }
  }

  acoef = 0;
  for (csz_idx_1 = 0; csz_idx_1 < 5; csz_idx_1++) {
    if (((unsigned int)TS + csz_idx_1) + 1U > 5U) {
      d_tmp_data[acoef] = csz_idx_1 + 1;
      acoef++;
    }
  }

  b_x1 = x1->size[1] + 1U;
  for (i5 = 0; i5 < 5; i5++) {
    uv1[i5] = i5 + b_x1;
  }

  b_x1 = x1->size[1] + 1U;
  for (i5 = 0; i5 < 5; i5++) {
    uv2[i5] = i5 + b_x1;
  }

  xf2_size[0] = 1;
  xf2_size[1] = k + trueCount;
  for (i5 = 0; i5 < k; i5++) {
    xf2_data[xf2_size[0] * i5] = xi2->data[xi2->size[0] * ((int)
      uv1[c_tmp_data[i5] - 1] - 1)];
  }

  for (i5 = 0; i5 < trueCount; i5++) {
    xf2_data[xf2_size[0] * (i5 + k)] = x2->data[x2->size[0] * ((int)((double)
      uv2[d_tmp_data[i5] - 1] - 5.0) - 1)];
  }
}

//
// File trailer for SimulateNarx.cpp
//
// [EOF]
//
